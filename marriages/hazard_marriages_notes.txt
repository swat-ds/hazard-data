HAZARD MARRIAGES

**S1 is the wife 
**S2 is the husband

create new column → column name: sort
random()

******NAMES******

**S1 name**

Note → edit column → add column based on this column → column name: S1 name
value.find(/(?[A-Z]\S*)+(?= dt)/)[0].trim()

S1 name → facet → customized facet → facet null → true
cells.Note.value.split("  ")[0].replace(/\./,"") 
**a way to capture S1 names that weren't captured with the previous facet

S1 name → edit cells → transform
value.replace(/,?1st|2nd|3rd/,"").replace(/\s{2}.*|,/,'').trim()
**removes 1st, 2nd, and 3rd from the beginning of the spouses name

S1 name → edit cells → transform
value.replace(/[Ww]idow.*|,/,'').trim()
**removes everything after S1 name

S1 name → edit cells → transform
value.replace(/,?wid[d]ow/,"")
**removes widow from the S1 name

---for [to m]---
S1 name → edit cells → transform
cells.Note.value.split("to m ")[1].replace(/\s{2}.*|,/,'').replace(/\./,"").trim()
**captures S1 names for [to m]

---for [ami[st]]---
S1 name → edit cells → transform
cells.Note.value.split("  ")[0].replace(/dt.*|,|;.*/,'').replace(/\./,"").trim()

**S1 Father**

Note → edit column → add column based on this column → column name: S1 Father
value.split("&")[0].split(" dt of")[1]

S1 Father → edit cells → transform
value.replace(/,?dec.*|,/,'').replace(/\s{2}.*|,/,'').trim()
**gets rid of everything after S1 F name

**S2 Father**

Note → edit column → add column based on this column → column name: S2 Father
value.split("&")[1].split(" S of")[1].replace(/\./, "")

S2 Father → facet → customized facet → facet null → true
cells.Note.value.split("&")[0].split(" S of")[1].replace(/\./, "")
**a way to capture S2 F names that weren't captured with the previous facet

S2 Father → edit cells → transform
value.replace(/,?dec.*|,/,'').replace(/\s{2}.*|,/,'').trim()
**gets rid of everything after S2 F name

**S1 Mother**

Note → edit column → add column based on this column → column name: S1 Mother
value.split("  S of")[0].split(" &")[1].replace(/\./,"") 

S1 Mother → facet → customized facet → facet null → true
cells.Note.value.split("  S of")[0].split(" &")[1].replace(/\./, "")
**a way to capture S1 M names that weren't captured with the previous facet

S1 Mother → edit cells → transform
value.replace(/,?dec|latter|both.*|,/,'').replace(/\s{2}.*|,/,'').trim()
**gets rid of everything after S1 Mother's name

**S2 Mother**

Note → edit column → add column based on this column → column name: S2 Mother
value.split("  S of")[1].split("  ")[0]
**this gives both S2 parents' names

S2 Mother → edit cells → transform
value.split("&")[1].split("  ")[0]
**captures just S2 Mother's name

S2 Mother → facet → customized facet → facet null → true
cells.Note.value.split("  S of")[1].split("  ")[0].split("&")[1].split("  ")[0].replace(/\./, "")
**a way to capture S2 M names that weren't captured with the previous facet

S2 Mother → facet → customized facet → facet null → true
cells.Note.value.split(" S of")[1].split("z ")[0].split("&")[1].split("  ")[0].replace(/\./, "")
**for some reason, adding a z captured 89 cells that were giving me trouble

S2 Mother → edit cells → transform
value.replace(/,?dec|latter|both.*|,/,'').replace(/\s{2}.*|,/,'').trim()
**gets rid of everything after S2 Mother's name


******DECEASED STATUS******

**S1 M dec**

Note → edit column → add column based on this column → column name: S1 M dec
value.split("  S of")[0].split(" &")[1].contains(/\bdec\b/) 
**if it says " dec" after S1 M name, then the S1 M dec will be true

S1 M dec → facet → text facet → (blank)
cells.Note.value.split("  S of")[0].split(" &")[1].contains(/\bdec\b/)
**ran this same code on the previously blank cells and filled in the majority of blank cells 

**S2 M dec**

Note → edit column → add column based on this column → column name: S2 M dec
value.split("  S of")[1].split("  ")[0].split(' & ')[1].contains(/\bdec\b/) 
**if it says " dec" after S2 M name, then the S2 M dec will be true

S2 M dec → facet → text facet → (blank)
cells.Note.value.split("  S of")[1].split("  ")[0].split(' & ')[1].contains(/\bdec\b/) 
**ran this same code on the previously blank cells and filled in the 49 blank cells 

**S1 F dec**

Note → edit column → add column based on this column → column name: S1 F dec
value.split("&")[0].split(" dt of")[1].contains(/\bdec\b/) 
**if it says " dec" after S1 F name, then the S1 F dec will be true

S1 F dec → facet → text facet → false
cells.Note.value.split("  S of")[0].split(" &")[1].contains(/\bboth dec\b/) 
**if it says "both dec" after S1 parents names, then the S1 F dec will be true

S1 F dec → facet → text facet → (blank)
cells.Note.value.split("&")[0].split(" dt of")[1].contains(/\bdec\b/) 
**ran this same code on the previously blank cells and filled in the majority of blank cells 

**S2 F dec**

Note → edit column → add column based on this column → column name: S2 F dec
value.split("  S of")[1].split("  ")[0].split(' & ')[0].contains(/\bdec\b/) 
**if it says " dec" after S2 F name, then the S2 F dec will be true

S2 F dec → facet → text facet → false
cells.Note.value.split("  S of")[1].split("  ")[0].split(' & ')[1].contains(/\bboth dec\b/) 
**if it says "both dec" after S2 parents names, then the S2 F dec will be true

S2 F dec → facet → text facet → (blank)
cells.Note.value.split("  S of")[1].split("  ")[0].split(' & ')[0].contains(/\bdec\b/) 
cells.Note.value.split("  S of")[1].split("  ")[0].split(' & ')[1].contains(/\bboth dec\b/) 
**ran both these code on the previously blank cells and filled in the 109 blank cells 


******PLACE OF MARRIAGE******

Note → edit column → add column based on this column → column name: Place of Marriage
value.split(/ [Aa]t/)[1]


******PREVIOUSLY MARRIED******

**S2 Previously Married**
Note → edit column → add column based on this column → column name: S2 Previously Married
value.contains(/1st|2nd|3rd/) 

S2 Previously Married → edit cells → transform
cells.Note.value.contains(/1st|2nd|3rd/) 
**ran on all cells and filled in blank cells

**S1 Previously Married**

Note → edit column → add column based on this column → column name: S1 Previously Married
value.contains(/[Ww]idow/)

S1 Previously Married → edit cells → transform
value.contains(/[Ww]iddow/)
**caught multiple spelling errors of the word "widow"

S1 Previously Married → edit cells → transform
cells.Note.value.contains(/[Ww]idow/)
**ran on all cells and filled in blank cells

---for [ami[st]]---
S1 Previously Married → edit cells → transform
value.contains(/[Ww]idow/)
**captured widows under [ami[st]]


Should I run this on S1 or S2????
cells.Note.value.contains(/[Dd]ivorced/)
**captures divorcees

******FORMER SPOUSES*****

Note → edit column → add column based on this column → column name: S1 Former Spouse(s)
value.split(/[Ww]idow of/)[1].split("?.")[0]

S1 Former Spouse(s) → edit cells → transform
cells.Note.value.split(/[Ww]iddow of/)[1].split("?.")[0]
**captured the S1 Former Spouse's names that appeared after the misspelling of "widow"

value.replace(/,?dec.*|,/,'').replace(/\s{2}.*|,/,'').replace(/\./,"").trim()
**removes everything after S1 Former Spouse's name

S2 Former Spouse(s)
**not sure if this is necessary (same as S1 name)

******NON-MEMBER*****

Note → edit column → add column based on this column → column name: S1 Non-Member
value.contains(/[Ss]he is not a mbr/)

S1 Non-Member → edit cells → transform
cells.Note.value.contains(/[Ss]he is not a mbr/)
**ran on all cells and filled in blank cells

Note → edit column → add column based on this column → column name: S2 Non-Member
value.contains(/ [Hh]e is not a mbr/)

S2 Non-Member → edit cells → transform
cells.Note.value.contains(/ [Hh]e is not a mbr/)
**ran on all cells and filled in blank cells


******ORIGINAL MM*****

Note → edit column → add column based on this column → column name: S2 Original MM
value.split("MM")[0].replace(/\s{2}.*|,/,'').replace(/\.|;/,"").trim()

S2 Original MM → text filter → "belonging" → edit cells → transform
value.split("to")[1]
**removed everything before the meeting name

S2 Original MM → edit cells → transform
cells.Note.value.split("belonging to")[1].split("MM")[0].replace(/\s{2}.*|,/,'').replace(/\.|;/,"").trim()
**captured a few extraneous cells













